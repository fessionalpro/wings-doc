import{_ as d,W as c,X as t,Z as e,a0 as o,$ as l,a2 as n,F as i}from"./framework-f37db9b8.js";const s={},r=n(`<h1 id="_2b-强类型及dsl能力" tabindex="-1"><a class="header-anchor" href="#_2b-强类型及dsl能力" aria-hidden="true">#</a> 2B.强类型及DSL能力</h1><blockquote><p>时间漫游，冲到目标位置，并取消最近2.0秒内受到的任何伤害。 虚空假面在时间漫游过程中为无敌状态。</p></blockquote><ul><li>从数据库自动生成jooq代码，pojo, table, dao</li><li>通过jooq的强类型，保证数据层面的变更和重构稳定</li></ul><h2 id="_2b-1-强类型的数据库操作" tabindex="-1"><a class="header-anchor" href="#_2b-1-强类型的数据库操作" aria-hidden="true">#</a> 2B.1.强类型的数据库操作</h2><p>推荐使用SqlMapping，因为ORM太重了，工程内使用Jooq和JdbcTemplate</p><p>MyBatis是国内大部分项目的首选，固有其优秀之处，但其约束力量的不够， 开发者的懒惰，使得基于字符串的sql难于安全重构，项目中容易蔓生以下问题，</p><ul><li>经常被<code>select *</code>，查询带有大量无用信息</li><li>很容易写出复杂的大SQL，使得服务难以拆分</li><li>字符串及弱类型，重构时，IDE的支持有限</li></ul><p>使用Jooq，有了强类型，使得编程优于配置，语法优于字符串， 并且其SQL表达友好，有恰到好处的限制能力的能力。</p><p>使用<code>WingsCodeGenerator</code>以编程的方式进行（不用maven）自动生成jooq代码。 按约定，生成代码在<code>database/autogen/</code>下，手动代码在<code>database/manual/</code>下。</p><p>若碰到wings或jooq的导致编译错误，无法在当前工程生成代码时， 需要建立一个新的小工程，仅依赖wings新版，执行代码生成工具即可。</p><p>自动生成的<code>*Dao</code>，有大量可直接使用的数据库操作方法，</p><ul><li><code>getAlias</code> 获得select用的别名表，<code>Table as az</code><ul><li>运行时，Table唯一，采用excel格式的az进制表示</li><li>自命名时，采用数字结尾，避免与系统发生冲突。</li></ul></li><li><code>getTable</code> 获得modify用的不使用别名的表 <code>Table</code></li><li>使用preparedStatement的batch批量插入和更新大量数据</li><li>使用mysql特效，<code>insert ignore</code>和<code>replace into</code>处理重复数据</li><li>使用<code>on duplicate key update</code>或<code>select+insert+update</code>部分更新唯一记录。</li></ul><p>值得注意的是，在Dao中使用alias表和本表时，必须保持同源，否则报语法错误。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> da <span class="token operator">=</span> dao<span class="token punctuation">.</span>alias
<span class="token comment">// val rd = dao.fetch(da.Id.eq(id)) 别名和本表不同源，语法错误</span>
<span class="token comment">// select * from win_user where \`y8\`.\`id\` = ?</span>

<span class="token keyword">val</span> rd <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>da<span class="token punctuation">,</span> da<span class="token punctuation">.</span>Id<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当有复杂数据操作，必须手写代码时，遵循以下约定，</p><ul><li>任何对数据库的操作，都应该在<code>database</code>包内进行</li><li>DSLContext和DataSource不应该离开database层</li><li><code>single/</code>包，表示单表，可含简单的条件子查询，一个包名一个表</li><li><code>couple/</code>包， 表示多表，一般为join查询或子查询，包名以主表命名</li><li>耦合操作，建议标记<code>@CouplingSelect</code>, <code>@CouplingModify</code></li><li><code>select|modify</code>分别对应数据库操作</li><li>也可以<code>select|insert|update|delete</code>分类，只是autowired时比较多</li><li>数据传递以Dto结尾，放到最临近使用的位子</li><li>Dto以静态内类形似存在，用lombok做@Value或@Data</li><li><code>forUpdate</code>这种带锁操作，方法名以<code>Lock</code>结尾</li><li>类名以<code>表名</code>+<code>Insert|Modify</code></li><li><code>Record</code>等同于<code>Dao</code>不应该在外部使用，应该用<code>Pojo</code>或<code>Dto</code></li><li>主要使用Dao，完成dsl等相关操作即可</li></ul><p>命名上，接口直接命名，不需要前后缀，Dto放在接口之内。 实现类，放到<code>impl/</code>包内，用后缀表示实现方式不同。</p><ul><li><code>Jooq</code> - Jooq实现</li><li><code>Jdbc</code> - JdbcTemplate实现</li><li><code>Impl</code> - 混合实现</li></ul><p>如<code>LightId</code>在读写分离时，需要强制master，可使用<code>@MasterRouteOnly</code>。</p>`,19),p={href:"http://jdbi.org",target:"_blank",rel:"noopener noreferrer"},u=n('<h2 id="_2b-2-sharding的兼容问题" tabindex="-1"><a class="header-anchor" href="#_2b-2-sharding的兼容问题" aria-hidden="true">#</a> 2B.2.Sharding的兼容问题</h2><p><code>flywave</code>包装了jooq的<code>Dao</code>，可按类型分为了<code>reader</code>和<code>writer</code>表，跟踪表。 强烈建议，使用<code>Dao</code>完成基础的CRUD操作，参见<code>JooqShardingTest.kt</code>。 使用dsl构造复杂的sql时，要考虑读写分离。更复杂的sql建议使用jdbcTemplate。</p><p>jooq生成代码，默认使用<code>table.column</code>限定列名，而ShardingJdbc做当前版本不支持。 最优解决办法是使ShardingJdbc支持，当前最简单的办法是修改Jooq生成策略，参考以下Issue。</p>',3),h={href:"https://github.com/jOOQ/jOOQ/issues/8893",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/jOOQ/jOOQ/pull/9055",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/apache/incubator-shardingsphere/issues/2859",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"table.column",-1),f={href:"https://github.com/apache/shardingsphere/issues/5330",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/apache/shardingsphere/issues/5210",target:"_blank",rel:"noopener noreferrer"},k=n('<p>在jooq<code>3.18</code>版本之前，使用<code>spring.wings.faceless.jooq.enabled.auto-qualify=true</code>， 完成限定名的自动处理，其规则是，<code>不存在alias时，不增加限定名</code>。</p><p>使用Jooq的主要原因是其<code>限制的艺术</code>，可避免写出难以拆分的SQL，</p><ul><li>鼓励单表操作，放在<code>single</code>包内，使用<code>本名</code>(如，WinUserLoginTable)</li><li>操作多表时，<code>别名</code>(如，WinUserLoginTable.asA2)优于<code>本名</code></li><li>INSERT 使用<code>本名</code>，不可使用<code>别名</code></li><li>DELETE 使用<code>本名</code>，不可使用<code>别名</code></li><li>UPDATE 使用<code>别名</code>优先于<code>本名</code></li><li>SELECT 单表时，用<code>本名</code>；多表时，<code>别名</code>优先于<code>本名</code></li><li><strong>不要</strong> 使用中文表名，例子代码只是极端测试。</li></ul><h2 id="_2b-3-record-mapper" tabindex="-1"><a class="header-anchor" href="#_2b-3-record-mapper" aria-hidden="true">#</a> 2B.3.Record Mapper</h2><p>jooq 默认有2中Mapper都区分大小写，对应的功能如下</p><ul><li>DefaultRecordMapper 负责Record#into(Class), Result#into(Class)</li><li>DefaultRecordUnmapper 负责DSL.newRecord(Table, Object), Record#from(Object)</li></ul><p>SimpleFlatMapper的mapper更为宽松，不区分大小写，但有以下不足。</p>',7),q={href:"https://github.com/arnaudroger/SimpleFlatMapper/issues/764",target:"_blank",rel:"noopener noreferrer"},j=e("li",null,"不支持primitive type，如int.class，仅Integer.class",-1),S=e("p",null,"官方在2020-05-11最后一次提交后，有2年多没有活跃了，wings于2022年10月已将其移除。",-1),w=e("p",null,"ModelMapper也比较优秀，但其体积过大（4.5M），目前没有必要使用，也未做充分测试。",-1),v=e("h2",{id:"_2b-4-参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2b-4-参考资料","aria-hidden":"true"},"#"),o(" 2B.4.参考资料")],-1),D={href:"https://github.com/trydofor/jOOQ/commit/0be23d2e90a1196def8916b9625fbe2ebffd4753",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.jooq.org/doc/3.12/manual/sql-execution/crud-with-updatablerecords/batch-execution-for-crud/",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.jooq.org/doc/3.12/manual/sql-execution/batch-execution/",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.jooq.org/doc/3.12/manual/sql-building/table-expressions/aliased-tables/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://www.jooq.org/doc/3.12/manual/sql-execution/",target:"_blank",rel:"noopener noreferrer"};function J(L,M){const a=i("ExternalLinkIcon");return c(),t("div",null,[r,e("p",null,[o("JdbcTemplate用于功能性的或复杂的数据库操作。若工程中有大量jdbc操作， 且感觉jdbcTemplate偏底层，可考虑"),e("a",p,[o("JDBI"),l(a)])]),u,e("ul",null,[e("li",null,[e("a",h,[o("JOOQ#8893 Add Settings.renderTable"),l(a)])]),e("li",null,[e("a",b,[o("JOOQ#9055 should NO table qualify if NO table alias"),l(a)])]),e("li",null,[e("a",_,[o("ShardingSphere#2859 "),g,o(" can not sharding"),l(a)])]),e("li",null,[e("a",f,[o("ShardingSphere#5330 replace into"),l(a)])]),e("li",null,[e("a",m,[o("ShardingSphere#5210 on duplicate key update"),l(a)])])]),k,e("ul",null,[e("li",null,[e("a",q,[o("intoArray的bug"),l(a)])]),j]),S,w,v,e("ul",null,[e("li",null,[e("a",D,[o("Jooq patch"),l(a)])]),e("li",null,[e("a",x,[o("批量操作 record"),l(a)])]),e("li",null,[e("a",O,[o("批量操作 jdbc"),l(a)])]),e("li",null,[e("a",T,[o("使用别名，支持分表"),l(a)])]),e("li",null,[e("a",y,[o("SQL的执行"),l(a)])])])])}const R=d(s,[["render",J],["__file","2b-jooq.html.vue"]]);export{R as default};
