import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,f as a}from"./app-6c801206.js";const i={},t=a(`<h1 id="_3c-host-extend-and-url-override" tabindex="-1"><a class="header-anchor" href="#_3c-host-extend-and-url-override" aria-hidden="true">#</a> 3C.Host Extend and URL Override</h1><p>Based on Mvc features to achieve the same backend app multiple different frontend host tenant function. Unlike reverse proxy (nginx) rewrite,</p><ul><li>extend - the child domain has all the URLs of the parent domain</li><li>override - the child domain can override the URL of the parent domain</li><li>child domains have their own separate URLs</li><li>domain inheritance is based on host</li></ul><h2 id="_3c-1-scenario-example" tabindex="-1"><a class="header-anchor" href="#_3c-1-scenario-example" aria-hidden="true">#</a> 3C.1.Scenario Example</h2><p>Assuming that <code>a.com</code> is a fully functional website, an example would include the following 3 URLs,</p><ul><li>GET /user-list.json - controller based</li><li>GET /css/main.css - static resource</li><li>GET /login.html - controller based</li></ul><p>At this point, we have a franchisee <code>b.com</code>, which is all the same as <code>a.com</code> except for the skin, and its own domain. Later on, <code>b.com</code> has its own requirements, and some of function and Url are different from <code>a.com</code>. The different functions are implemented independently and put under the convention prefix, at this time the URLs are distributed as follows.</p><ul><li>GET /login.html - <code>a.com</code>(parent), <code>b.com</code>(child)</li><li>GET /user-list.json - <code>a.com</code>(parent)</li><li>GET /css/main.css - <code>a.com</code>(parent)</li><li>GET /domain/b/user-list.json - <code>b.com</code>(child)</li><li>GET /domain/b/css/main.css - <code>b.com</code>(child)</li></ul><p>When the user visits the following URL, according to the parent-child override rules of Java, the following is called,</p><ul><li><code>a.com/login.html</code> - /login.html(parent)</li><li><code>a.com/user-list.json</code> - /user-info.list(parent)</li><li><code>a.com/css/main.css</code> - /css/main.css(parent)</li><li><code>b.com/login.html</code> - /login.html(parent)</li><li><code>b.com/user-list.json</code> - /domain/b/user-list.json(child)</li><li><code>b.com/css/main.css</code> - /domain/b/css/main.css(child)</li></ul><p>In the actual project, the above scenario mostly happens in the Mapping of resource and controller.</p><ul><li>Resource usually has a <code>**</code> match, use reflection in ResourceHttpRequestHandler.getResource to check</li><li>If not ResourceHttpRequestHandler and match <code>**</code>, you need to try the resource exists by yourself</li><li>temporarily do not support viewTemplate, but also suggest that templates must use the full path</li></ul><p>According to Wings mapping convention, avoid using relative paths, so b.com be prefixed at the class level</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/domain/b&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user-info.json&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">fetchUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// View has no support and must be set manually</span>
        <span class="token keyword">return</span> <span class="token string">&quot;/domain/b/user-info&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3c-2-underlying-principle" tabindex="-1"><a class="header-anchor" href="#_3c-2-underlying-principle" aria-hidden="true">#</a> 3C.2.Underlying Principle</h2><p>In SpringMvc system, a request enters the servlet container in the worker thread,</p><ul><li>Filter#doFilter <code>before</code> chain.doFilter</li><li>DispatcherServlet#doService <code>call</code> doDispatch</li><li>Filter#doFilter <code>after</code> chain.doFilter</li></ul><p>Wings use WingsDomainFilter, first check the host, if it is an inherited domain, then construct the subdomain full path url. By checking the cache and the HandlerMapping in DispatchServlet, construct a RequestWrapper.</p><p>For example, the user visits the URL /user/login.json, assuming that the domain is inheritance and the host is trydofor. The actual resource accessed on the server side is /prefix/trydofor/user/login.json</p><p>That is, the path <code>/\${prefix}/\${host}</code> is added before the client request the URI. Knowledge extension.</p><ul><li>Request is available before the FilterChain.doFilter call, and Response is available afterwards, with thread safety and performance in mind.</li><li>Default static resources in the classpath <code>/static</code>, <code>/public</code>, <code>/resources</code>, <code>/META-INF/resources</code></li></ul>`,21),o=[t];function c(l,r){return n(),s("div",null,o)}const u=e(i,[["render",c],["__file","3c-host-ext.html.vue"]]);export{u as default};
