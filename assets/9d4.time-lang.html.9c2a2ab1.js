import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as n,c as r,b as e,e as a,d as l,f as o,r as d}from"./app.1189c37f.js";const s={},c=o('<h1 id="_9d4-自动转换时间和语言" tabindex="-1"><a class="header-anchor" href="#_9d4-自动转换时间和语言" aria-hidden="true">#</a> 9D4.自动转换时间和语言</h1><p>语言和时区的细致处理，是WingsBoot的重要特点，也是有别于其他框架的重要特征。</p><ul><li>时间 - 可以系统级，线程级的调制时钟</li><li>时区 - 通过注解或类型，完成Dto/pojo的自动转换</li><li>语言 - MessageCode, EnumCode常量和强类型化，同时支持自动转换</li></ul><h2 id="时钟及时间线的调制" tabindex="-1"><a class="header-anchor" href="#时钟及时间线的调制" aria-hidden="true">#</a> 时钟及时间线的调制</h2><p>通常系统内有两种时钟，系统时钟和业务时钟，前者要求线性时间线，后者可能要求穿越。 尤其在测试，推演及复盘的时候，系统时钟也可能要调制到不同的时间线。</p><ul><li>mirana的<code>ThreadNow</code>和<code>SlideDate</code> 基础版时钟调制</li><li>slardar的<code>Now</code> 升级版的时钟调制，可调制用户时间线</li></ul><p>因此，在编写程序时，若该功能需要调整时间线（建议全部业务代码）</p><ul><li><code>Now.xxx()</code> 代替 <code>Xxxx.now()</code> 有slardar依赖时</li><li><code>ThreadNow.xxx()</code> 代替，无slardar依赖，但有mirana依赖</li></ul><p>需要注意的是，业务的线程模型是否支持ThreadLocal的Inheritable。</p><ul><li>ThreadNow默认使用ThreadLocal</li><li>Now默认使用TransmittableThreadLocal覆盖ThreadNow的默认值</li></ul>',10),h={href:"http://xn--ThreadNow-fe7nw8w.xxx",target:"_blank",rel:"noopener noreferrer"},u=o(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Benchmark     Mode  Cnt      Score     Error   Units
NowMain.now  thrpt    6  11942.923 ± 368.430  ops/ms
NowMain.sys  thrpt    6  12910.824 ± 226.997  ops/ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="时间和文字的i18n转换" tabindex="-1"><a class="header-anchor" href="#时间和文字的i18n转换" aria-hidden="true">#</a> 时间和文字的I18n转换</h2><p>WingsBoot的自动转换，依赖于两个Context获取ZoneId和Locale</p><ul><li>spring的<code>LocaleContextHolder</code>，Web层使用</li><li>slardar的<code>TerminalContext</code>，推荐使用，尤其Service层</li></ul><p>自动转换发生在SpringMvc的Request和Response，分别为</p><ul><li>Jackson的@RequestBody，@ResponseBody</li><li>Spring的Data Binding，如@Param</li></ul><p>手动转换通过<code>AutoDtoHelper</code>进行，如Excel输出，但要避开自动转换。</p><ul><li>默认仅对注解标记的字段生效，而自动转换可按类型处理</li><li>默认仅支持有getter的非final及transient字段</li></ul><p>自动转换涉及的类型和配置项为</p><ul><li>LocaleDateTime - wings.slardar.datetime.datetime.auto=false</li><li>ZonedDateTime - wings.slardar.datetime.zoned.auto=false</li><li>OffsetDateTime - wings.slardar.datetime.offset.auto=true</li><li>I18nString - 无配置，自动转换</li></ul><p>自动及手工转换涉及的注解为</p><ul><li>AutoDtoAble - 标注容器类字段（仅手动转换）</li><li>AutoI18nString - 标注String或I18nString类型</li><li>AutoTimeZone - 标注Local/Zoned/Offset的DateTime</li></ul><h2 id="context的规则和隐患" tabindex="-1"><a class="header-anchor" href="#context的规则和隐患" aria-hidden="true">#</a> Context的规则和隐患</h2><p>所有Context隐式传递变量，都是有副作用的，被视为反模式，要遵循规则，谨慎使用。 Wings中要避免函数具有副作用(SideEffect)，但Context确实提供了便利，非常好用。</p><p>Context中经常使用ThreadLocal作为承载，而ThreadLocal必须要正确的set和remove。 要么在<code>try{set}finally{remove}</code>，要么通过机制保证不会出现取值错误或内存泄露。</p>`,15),p={href:"https://github.com/alibaba/transmittable-thread-local",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,"在线程模型复杂的场景，一定要遵循Transmittable-ThreadLocal的原则和事项， 以正确处理Context，从而确保业务代码的正确性。",-1),x=e("ul",null,[e("li",null,"TerminalContext - 由slardar的TerminalInterceptor处理"),e("li",null,[a("Now - 按业务要求，需要自行"),e("code",null,"try{adjust()}finally{remove()}")])],-1);function _(f,T){const t=d("ExternalLinkIcon");return n(),r("div",null,[c,e("p",null,[e("a",h,[a("关于ThreadNow.xxx"),l(t)]),a("()和Xxx.now()的jmh Benchmark 基本相同")]),u,e("p",null,[a("Wings以"),e("a",p,[a("Transmittable-ThreadLocal"),l(t)]),a("作为基础， 尽可能使用TransmittableThreadLocal，并把Spring的Executor包装为TtlExecutors，保证正确传递Context。")]),m,x])}const w=i(s,[["render",_],["__file","9d4.time-lang.html.vue"]]);export{w as default};
